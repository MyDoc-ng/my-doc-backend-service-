generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["fullTextSearchPostgres"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum Gender {
  MALE
  FEMALE
}

enum UserTypes {
  ADMIN
  PATIENT
  DOCTOR
}

enum SessionType {
  CHAT
  AUDIO
  VIDEO
  CLINIC
  HOME
}

enum AppointmentStatus {
  PENDING
  UPCOMING
  COMPLETED
  CONFIRMED
  CANCELLED
}

enum TransactionType {
  TOP_UP
  CONSULTATION
  REFERRAL
}

enum PaymentStatus {
  PENDING
  SUCCESSFUL
  FAILED
}

enum NotificationType {
  VIDEO_CALL
  NEW_MESSAGE
  SCHEDULE_CHANGED
  ACCOUNT_APPROVED
  ACCOUNT_REJECTED
  APPOINTMENT_SUCCESS
  APPOINTMENT_REMINDER
  APPOINTMENT_SCHEDULED
  APPOINTMENT_RESCHEDULED
  APPOINTMENT_CANCELLED
}

model User {
  id                String    @id @default(uuid())
  role              UserTypes @default(PATIENT)
  name              String
  email             String    @unique
  password          String?
  emailVerified     Boolean   @default(false)
  verificationToken String?
  googleId          String?   @unique
  facebookId        String?   @unique

  patientProfile PatientProfile?
  doctorProfile  DoctorProfile?
  adminProfile   AdminProfile?

  PatientReviews       Review[]         @relation(name: "PatientReviews")
  DoctorReviews        Review[]         @relation(name: "DoctorReviews")
  RefreshToken         RefreshToken[]
  DoctorPayments       Payment[]        @relation(name: "DoctorPayments")
  PatientPayments      Payment[]        @relation(name: "PatientPayments")
  MedicalHistory       MedicalHistory[]
  MedicalRecord        MedicalRecord[]
  doctorConsultations  Consultation[]   @relation(name: "DoctorConsultations")
  patientConsultations Consultation[]   @relation(name: "PatientConsultations")
  ReceiverMessages     ChatMessage[]    @relation(name: "ReceiverMessages")
  SenderMessages       ChatMessage[]    @relation(name: "SenderMessages")
  Notification         Notification[]

  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  deletedAt DateTime?

  @@map("users")
}

model PatientProfile {
  id     String @id @default(uuid())
  userId String @unique
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  dateOfBirth    DateTime?        @db.Date
  gender         Gender           @default(MALE)
  address        String?
  phoneNumber    String?          @unique
  profilePicture String?
  medicalHistory MedicalHistory[]
  medicalRecords MedicalRecord[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model DoctorProfile {
  id     String @id @default(uuid())
  userId String @unique
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  experience            Int?
  certifications        String?
  location              String?
  consultationTypes     SessionType[]
  consultationFees      Float?
  homeVisitCharge       Float?
  videoConsultationFee  Float?
  clinicConsultationFee Float?
  availability          DoctorAvailability[]
  isOnline              Boolean              @default(false)
  lastActive            DateTime?
  bio                   String?
  reference             String?              @unique
  cv                    String?
  medicalLicense        String?
  isApproved            Boolean              @default(false)
  balance               Float                @default(0)
  googleCalendarId      String?
  googleRefreshToken    String?
  profilePicture        String?

  specialtyId String?
  specialty   Specialty? @relation(fields: [specialtyId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model AdminProfile {
  id     String @id @default(uuid())
  userId String @unique
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  permissions String[] // List of admin permissions

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model MedicalHistory {
  id               String          @id @default(uuid())
  userId           String
  user             User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  pastSurgeries    Boolean
  currentMeds      Boolean
  drugAllergies    Boolean
  PatientProfile   PatientProfile? @relation(fields: [patientProfileId], references: [id])
  patientProfileId String?

  @@map("medical_histories")
}

model MedicalRecord {
  id                  String            @id @default(uuid())
  userId              String
  user                User              @relation(fields: [userId], references: [id])
  consultationSummary String?
  diagnosis           String?
  treatmentPlan       String?
  prescriptions       Prescription[]
  labResults          LabResult[]
  radiologyReports    RadiologyReport[]
  createdAt           DateTime          @default(now())
  updatedAt           DateTime          @updatedAt
  PatientProfile      PatientProfile?   @relation(fields: [patientProfileId], references: [id])
  patientProfileId    String?

  @@map("medical_records")
}

model Prescription {
  id              String         @id @default(uuid())
  medicalRecordId String?
  medicalRecord   MedicalRecord? @relation(fields: [medicalRecordId], references: [id])
  medicationName  String
  dosage          String
  frequency       String
  notes           String?
  createdAt       DateTime       @default(now())
  updatedAt       DateTime       @updatedAt

  @@map("prescriptions")
}

model LabResult {
  id              String         @id @default(uuid())
  medicalRecordId String?
  medicalRecord   MedicalRecord? @relation(fields: [medicalRecordId], references: [id])
  testName        String
  result          String
  referenceRange  String?
  reportUrl       String? // URL to the lab report (e.g., PDF)
  createdAt       DateTime       @default(now())
  updatedAt       DateTime       @updatedAt

  @@map("lab_results")
}

model RadiologyReport {
  id              String         @id @default(uuid())
  medicalRecordId String?
  medicalRecord   MedicalRecord? @relation(fields: [medicalRecordId], references: [id])
  studyType       String
  finding         String?
  impression      String?
  reportUrl       String? // URL to the radiology report (e.g., PDF)
  createdAt       DateTime       @default(now())
  updatedAt       DateTime       @updatedAt

  @@map("radiology_reports")
}

model ChatMessage {
  id          String    @id @default(uuid())
  senderId    String
  receiverId  String
  content     String?
  attachments Json? // Store multiple file URLs or metadata
  voiceUrl    String?
  readAt      DateTime? // When the message was read
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  deletedAt   DateTime? 

  // Relationships
  sender   User @relation(fields: [senderId], references: [id], name: "SenderMessages")
  receiver User @relation(fields: [receiverId], references: [id], name: "ReceiverMessages")

  @@map("chat_messages")
}

model Consultation {
  id                 String            @id @default(uuid())
  doctorId           String
  patientId          String
  status             AppointmentStatus @default(PENDING)
  consultationType   SessionType
  googleMeetLink     String?
  notes              String?
  startTime          DateTime
  endTime            DateTime
  googleEventId      String? // ID of the event in Google Calendar
  cancellationReason String? // Store the reason

  cancelledAt DateTime? // Track cancellation time
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  patient User @relation(fields: [patientId], references: [id], name: "PatientConsultations")
  doctor  User @relation(fields: [doctorId], references: [id], name: "DoctorConsultations")

  @@map("consultations")
}

model Specialty {
  id            String          @id @default(uuid())
  name          String          @unique()
  DoctorProfile DoctorProfile[]

  @@map("specialties")
}

model DoctorAvailability {
  id       String   @id @default(uuid())
  doctorId String
  date     DateTime
  time     String // Store time as a string like "10:00 AM", "11:00 AM"

  DoctorProfile   DoctorProfile? @relation(fields: [doctorProfileId], references: [id])
  doctorProfileId String?

  @@map("doctor_availabilities")
}

model Payment {
  id            String        @id @default(uuid())
  userId        String
  doctorId      String? // Optional: Some payments might not be to a doctor
  amount        Float
  status        PaymentStatus @default(PENDING)
  transactionId String        @unique
  createdAt     DateTime      @default(now())

  user   User  @relation(fields: [userId], references: [id], name: "PatientPayments")
  doctor User? @relation(fields: [doctorId], references: [id], name: "DoctorPayments")

  @@map("payments")
}

model RefreshToken {
  id        String   @id @default(uuid())
  token     String   @unique
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    String
  expiresAt DateTime
  createdAt DateTime @default(now())

  @@map("refresh_tokens")
}

model Notification {
  id        String           @id @default(uuid())
  title     String
  message   String
  type      NotificationType
  isRead    Boolean          @default(false)
  createdAt DateTime         @default(now())

  recipientId String
  user        User   @relation(fields: [recipientId], references: [id], onDelete: Cascade)

  @@index([recipientId])
}

model Review {
  id        String   @id @default(uuid())
  doctorId  String
  patientId String
  rating    Int
  comment   String?
  createdAt DateTime @default(now())

  doctor  User @relation(fields: [doctorId], references: [id], name: "DoctorReviews")
  patient User @relation(fields: [patientId], references: [id], name: "PatientReviews")
}
